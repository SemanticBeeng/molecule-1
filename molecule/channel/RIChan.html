<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>molecule.channel.RIChan</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../lib/template.css" />
      <script type="text/javascript" src="../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
    
        </head>
        <body onload="sh_highlightDocument('../lib/', '.min.js');" class="type">
      <div id="definition">
        <a title="Go to companion" href="RIChan$.html"><img src="../../lib/class_to_object_big.png" /></a>
        <p id="owner"><a name="molecule" class="extype" href="../package.html">molecule</a>.<a name="molecule.channel" class="extype" href="package.html">channel</a></p>
        <h1><a title="Go to companion" href="RIChan$.html">RIChan</a></h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">RIChan</span><span class="tparams">[<span name="A">+A</span>]</span><span class="result"> extends <a name="molecule.channel.IChan" class="extype" href="IChan.html">IChan</a>[A]</span>
      </span>
      </h4>
      
      <div class="fullcommenttop" id="comment"><div class="comment cmt"><p>&quot;Result&quot;, &quot;reply&quot; or &quot;response&quot; input channel interface.</p><p>Result channels are system-level input channels that deliver only
a single message followed by the EOS. They obey channel semantics in that
they cannot be read concurrently and they deliver messages only
once - a result channel that is read a second time will deliver the
EOS signal.</p><p>The computations associated to a result channel, and hence
transformations like <code>map</code> or <code>flatMap</code>, are only fired lazyliy when
a process attempts to read the result from the channel. Transformations
featuring side-effects can be executed even if no one is
interested in the result by calling the <code>fire()</code> method. This method
returns a new result channel that consumes the result after the
transformations have been applied and then stores it internally
in an intermediate buffer such that it can still be consumed later.</p><p>In all situations, the continuations or the transformation functions
applied to a result channel are carried by default inside the
thread that produces the result. To improve reactiveness and/or isolate
concurrent computations from each other, it is prefereable to free as
soon as possible the thread that produces results and offload the
computation of transformations to the thread that consumes the result.
The <code>dispatchTo</code> method, if it is called immediately after a future
is created, will dipatch any subsequent continuation or transformation
to the standard <code>juc.Executor</code> that it is passed as parameter. For example,
this could be either a <a name="molecule.platform.Platform" class="extype" href="../platform/Platform.html">Platform</a> or a
<a name="molecule.platform.UThread" class="extype" href="../platform/UThread.html">UThread</a>, which both inherit from the <code>Executor</code>
interface. In the first case, continuations will be carried inside a new
user-level thread created by the target platform. In the second case,
the continuations will be pinned down to an existing user-level thread.</p><p>Note that in case a message is pure, the result of a result channel
can be cached for multiple (sequential) reads using the
<code>cache()</code> method. Alternatively, for
interoperability with Java, a result can also be wrapped
inside a standard <code>juc.Future</code> by invoking the <code>future()</code> method
on result channels (this method is provided via an implicit conversion
to <code>RIChanWithFuture</code> in the companion object).
</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>the type of the message returned by the channel
</p></dd></dl><dl class="attributes block"> <dt>Self Type</dt><dd><a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[A]</dd><dt>Source</dt><dd><a target="_blank" href="https://github.com/molecule-labs/molecule/tree/develop/molecule-core/src/main/scala/molecule/channel/RChan.scala">RChan.scala</a></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a name="molecule.channel.IChan" class="extype" href="IChan.html">IChan</a>[A], AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div></div>
    

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
            </div>
        <div id="ancestors">
              <span class="filtertype">Inherited</span>
              <ol><li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li></ol>
              <ol id="linearization"><li name="molecule.channel.RIChan" class="in"><span>RIChan</span></li><li name="molecule.channel.IChan" class="in"><span>IChan</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
            </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div class="members" id="constructors">
              <h3>Instance Constructors</h3>
              <ol><li visbl="pub" name="molecule.channel.RIChan#this" data-isabs="false">
      <a id="this:RIChan[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">RIChan</span><span class="params">()</span>
      </span>
      </h4>
      <p class="shortcomment cmt"></p>
    </li></ol>
            </div>

        

        <div class="values members" id="values">
              <h3>Abstract Value Members</h3>
              <ol><li visbl="pub" name="molecule.channel.IChan#poison" data-isabs="true">
      <a id="poison(Signal):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">poison</span><span class="params">(<span name="signal">signal: <a name="molecule.Signal" class="extype" href="../Signal.html">Signal</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Poison this channel and any segment it may have buffered.</p><div class="fullcomment"><div class="comment cmt"><p>Poison this channel and any segment it may have buffered.
</p></div><dl class="paramcmts block"><dt class="param">signal</dt><dd class="cmt"><p>the poison signal.</p></dd><dt>returns</dt><dd class="cmt"><p>Unit
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="molecule.channel.IChan" class="extype" href="IChan.html">IChan</a></dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#read" data-isabs="true">
      <a id="read((A) ⇒ Unit,(Signal) ⇒ Unit):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">read</span><span class="params">(<span name="success">success: (A) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="failure">failure: (<a name="molecule.Signal" class="extype" href="../Signal.html">Signal</a>) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Read a result asynchronously using continuations for success and
failure cases.</p><div class="fullcomment"><div class="comment cmt"><p>Read a result asynchronously using continuations for success and
failure cases.
</p></div><dl class="paramcmts block"><dt class="param">success</dt><dd class="cmt"><p>continuation invoked in case of success.</p></dd><dt class="param">failure</dt><dd class="cmt"><p>continuation invoked in case of failure.</p></dd><dt>returns</dt><dd class="cmt"><p>unit
</p></dd></dl></div>
    </li></ol>
            </div>

        <div class="values members" id="values">
              <h3>Concrete Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#and" data-isabs="false">
      <a id="and[B](RIChan[B])(Message[A],Message[B]):RIChan[(A, B)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">and</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="other">other: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ma">ma: <a name="molecule.Message" class="extype" href="../Message.html">Message</a>[A]</span>, <span name="mb">mb: <a name="molecule.Message" class="extype" href="../Message.html">Message</a>[B]</span>)</span><span class="result">: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[(A, B)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return both the result of this channel and the one of another channel.</p><div class="fullcomment"><div class="comment cmt"><p>Return both the result of this channel and the one of another channel.</p><p>The new channel created succeeds with both successful results or
fails as soon as one of the RIChan fails.
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>the other result channel.</p></dd><dt>returns</dt><dd class="cmt"><p>a pair containing the the result of this channel and the other one.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#cache" data-isabs="false">
      <a id="cache()(Message[A]):RIChan[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cache</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="ma">ma: <a name="molecule.Message" class="extype" href="../Message.html">Message</a>[A]</span>)</span><span class="result">: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[A]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Cache the message received on the underlying channel such that the same result
can be read multiple times (sequentially).</p><div class="fullcomment"><div class="comment cmt"><p>Cache the message received on the underlying channel such that the same result
can be read multiple times (sequentially).</p><p>Important note: Caching messages violates uniqueness of references. Therefore, one
must ensure that only &quot;Pure&quot; messages are cached using this mechanism or be
careful when poisoning the resulting channel.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a result channel that can be read multiple times.
</p></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#dispatchTo" data-isabs="false">
      <a id="dispatchTo(Executor):RIChan[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dispatchTo</span><span class="params">(<span name="executor">executor: <span name="java.util.concurrent.Executor" class="extype">Executor</span></span>)</span><span class="result">: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[A]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a new result channel whose transformations will be executed in the
context of another executor.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new result channel whose transformations will be executed in the
context of another executor. The executor might be a Platform or a
user-level thread (UThread), which both implement the juc.Executor interface.
</p></div><dl class="paramcmts block"><dt class="param">executor</dt><dd class="cmt"><p>the executor that will execute the subsequent transformations.</p></dd><dt>returns</dt><dd class="cmt"><p>a result channel whose continuations will be invoked in the context
of the executor.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#fire" data-isabs="false">
      <a id="fire()(Message[A]):RIChan[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fire</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="m">m: <a name="molecule.Message" class="extype" href="../Message.html">Message</a>[A]</span>)</span><span class="result">: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[A]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Execute all the transformations stacked up on this result channel, and then
cache the result into a new result channel.</p><div class="fullcomment"><div class="comment cmt"><p>Execute all the transformations stacked up on this result channel, and then
cache the result into a new result channel. This method ensures that all
side-effects performed by transformations applied on this result channel
are executed, even if this future is not consumed. Note that it is useless
to invoke this method if transformations have no side-effects.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a RIChan.
</p></dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#flatMap" data-isabs="false">
      <a id="flatMap[B]((A) ⇒ RIChan[B]):RIChan[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (A) ⇒ <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[B]</span>)</span><span class="result">: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Schedule another asynchronous continuation, which is a function of
the result of this channel.</p><div class="fullcomment"><div class="comment cmt"><p>Schedule another asynchronous continuation, which is a function of
the result of this channel.</p><p>The thread that executes the function is defined by how this result
channel was created.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function that creates a new asynchronous computation
  using the success result of this channel interface.</p></dd><dt>returns</dt><dd class="cmt"><p>a new channel interface obtained by chaining a new computation after
this result is available.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#get_!" data-isabs="false">
      <a id="get_!():A"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: get_$bang">get_!</span><span class="params">()</span><span class="result">: A</span>
      </span>
      </h4>
      <p class="shortcomment cmt">BLOCK the native thread until a result is available.</p><div class="fullcomment"><div class="comment cmt"><p>BLOCK the native thread until a result is available.</p><p>All transformations applied before the result channel (or after a FutureRIChan) was
was created will be applied in the same native thread than the one that blocks on
this result.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the result.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#map" data-isabs="false">
      <a id="map[B]((A) ⇒ B):RIChan[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (A) ⇒ B</span>)</span><span class="result">: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Map a function to the result of this channel interface.</p><div class="fullcomment"><div class="comment cmt"><p>Map a function to the result of this channel interface.</p><p>The thread that executes the function is defined by how this result
channel was created.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function applied to the result produced by this channel
         in case of success.</p></dd><dt>returns</dt><dd class="cmt"><p>A new channel interface obtained by applying <code>f</code> to the result
of this channel interface.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#onComplete" data-isabs="false">
      <a id="onComplete((A) ⇒ Unit,(Signal) ⇒ Unit):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onComplete</span><span class="params">(<span name="success">success: (A) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>, <span name="failure">failure: (<a name="molecule.Signal" class="extype" href="../Signal.html">Signal</a>) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">React to a result asynchronously using continuations for success
and failure cases.</p><div class="fullcomment"><div class="comment cmt"><p>React to a result asynchronously using continuations for success
and failure cases.
</p></div><dl class="paramcmts block"><dt class="param">success</dt><dd class="cmt"><p>continuation invoked in case of success.</p></dd><dt class="param">failure</dt><dd class="cmt"><p>continuation invoked in case of failure.</p></dd><dt>returns</dt><dd class="cmt"><p>unit
</p></dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#or" data-isabs="false">
      <a id="or[B](RIChan[B])(Message[A],Message[B]):RIChan[Either[A, B]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">or</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="other">other: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ma">ma: <a name="molecule.Message" class="extype" href="../Message.html">Message</a>[A]</span>, <span name="mb">mb: <a name="molecule.Message" class="extype" href="../Message.html">Message</a>[B]</span>)</span><span class="result">: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[<span name="scala.Either" class="extype">Either</span>[A, B]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Choose the first result between the result of this channel and the one of
another channel.</p><div class="fullcomment"><div class="comment cmt"><p>Choose the first result between the result of this channel and the one of
another channel.</p><p>The new result channel created succeeds with the first successful result
returned by either this channel or the other channel. It fails only
if both channels fail. The other result channel will be automatically
poisoned once a result becomes available.
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>the other result channel.</p></dd><dt>returns</dt><dd class="cmt"><p>either the result of this channel or the result of the other one.
</p></dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#orCatch" data-isabs="false">
      <a id="orCatch[B&gt;:A](PartialFunction[Signal, RIChan[B]]):RIChan[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">orCatch</span><span class="tparams">[<span name="B">B &gt;: A</span>]</span><span class="params">(<span name="recover">recover: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[<a name="molecule.Signal" class="extype" href="../Signal.html">Signal</a>, <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[B]]</span>)</span><span class="result">: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fallback to an alternative result channel if this channel raises a signal
instead of returning a result.</p><div class="fullcomment"><div class="comment cmt"><p>Fallback to an alternative result channel if this channel raises a signal
instead of returning a result.
</p></div><dl class="paramcmts block"><dt class="param">recover</dt><dd class="cmt"><p>the partial function invoked if a signal is raised.</p></dd><dt>returns</dt><dd class="cmt"><p>a new result channel.
</p></dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#read" data-isabs="false">
      <a id="read((Seg[A], IChan[A]) ⇒ Unit):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">read</span><span class="params">(<span name="k">k: (Seg[A], <a name="molecule.channel.IChan" class="extype" href="IChan.html">IChan</a>[A]) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Read a segment from this channel.</p><div class="fullcomment"><div class="comment cmt"><p>Read a segment from this channel.
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>the continuation taking the last segment read as parameter
         and the seed on which to read subsequent segments.</p></dd><dt>returns</dt><dd class="cmt"><p>Unit
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="molecule.channel.RIChan" class="extype" href="">RIChan</a> → <a name="molecule.channel.IChan" class="extype" href="IChan.html">IChan</a></dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#readWithin" data-isabs="false">
      <a id="readWithin(Long,TimeUnit)(Message[A]):RIChan[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">readWithin</span><span class="params">(<span name="delay">delay: <span name="scala.Long" class="extype">Long</span></span>, <span name="unit">unit: <span name="java.util.concurrent.TimeUnit" class="extype">TimeUnit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ma">ma: <a name="molecule.Message" class="extype" href="../Message.html">Message</a>[A]</span>)</span><span class="result">: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[<span name="scala.Option" class="extype">Option</span>[A]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Read the result of a result channel within the specified timeout.</p><div class="fullcomment"><div class="comment cmt"><p>Read the result of a result channel within the specified timeout. If the
result is no available within the specified timeout, this channel will
be automatically poisoned.
</p></div><dl class="paramcmts block"><dt class="param">delay</dt><dd class="cmt"><p>the time from now to delay execution.</p></dd><dt class="param">unit</dt><dd class="cmt"><p>the time unit of the delay parameter.</p></dd><dt>returns</dt><dd class="cmt"><p>some result if the result becomes available before the timeout,
        else none.
</p></dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#select" data-isabs="false">
      <a id="select[B](RIChan[B])(Message[A],Message[B]):RIChan[Either[(A, RIChan[B]), (B, RIChan[A])]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">select</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="other">other: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[B]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ma">ma: <a name="molecule.Message" class="extype" href="../Message.html">Message</a>[A]</span>, <span name="mb">mb: <a name="molecule.Message" class="extype" href="../Message.html">Message</a>[B]</span>)</span><span class="result">: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[<span name="scala.Either" class="extype">Either</span>[(A, <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[B]), (B, <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[A])]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Choose the first result between the result of this channel and the one of
another channel.</p><div class="fullcomment"><div class="comment cmt"><p>Choose the first result between the result of this channel and the one of
another channel.</p><p>The new result channel created succeeds with the first successful result
returned by either this channel or the other channel. It fails only
if both channels fail. Whenever one of the result channels succeeds,
the other result channel is returned with the result such that one
can attempt to retrieve the other result a second time later.
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>the other result channel.</p></dd><dt>returns</dt><dd class="cmt"><p>either the result of this channel or the result of the other one.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="molecule.channel.RIChan#tryReadWithin" data-isabs="false">
      <a id="tryReadWithin(Long,TimeUnit)(Message[A]):RIChan[Either[RIChan[A], A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tryReadWithin</span><span class="params">(<span name="delay">delay: <span name="scala.Long" class="extype">Long</span></span>, <span name="unit">unit: <span name="java.util.concurrent.TimeUnit" class="extype">TimeUnit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ma">ma: <a name="molecule.Message" class="extype" href="../Message.html">Message</a>[A]</span>)</span><span class="result">: <a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[<span name="scala.Either" class="extype">Either</span>[<a name="molecule.channel.RIChan" class="extype" href="">RIChan</a>[A], A]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Try to read the result of a result channel within the specified timeout.</p><div class="fullcomment"><div class="comment cmt"><p>Try to read the result of a result channel within the specified timeout. If
the result is not available before the specified timeout, a new result channel
is returned, which can be used to retrieve the result again later.
</p></div><dl class="paramcmts block"><dt class="param">delay</dt><dd class="cmt"><p>the time from now to delay execution.</p></dd><dt class="param">unit</dt><dd class="cmt"><p>the time unit of the delay parameter.</p></dd><dt>returns</dt><dd class="cmt"><p>Either the result if it becomes available before the timeout, or a new result
               channel, which can be read a second time later.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        
        </div>

        <div id="inheritedMembers">
        <div name="molecule.channel.IChan" class="parent">
              <h3>Inherited from <a name="molecule.channel.IChan" class="extype" href="IChan.html">IChan</a>[A]</h3>
            </div><div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>